<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Meijin's Tech Tips</title><link>https://tech-memo.meijin.dev/</link><description>Recent content on Meijin's Tech Tips</description><image><url>https://tech-memo.meijin.dev/site-feature-image.png</url><link>https://tech-memo.meijin.dev/site-feature-image.png</link></image><generator>Hugo -- gohugo.io</generator><language>ja-JP</language><lastBuildDate>Thu, 14 Oct 2021 00:00:00 +0900</lastBuildDate><atom:link href="https://tech-memo.meijin.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust製Tmux代替のZellijに入門</title><link>https://tech-memo.meijin.dev/posts/zellij-intro/</link><pubDate>Thu, 14 Oct 2021 00:00:00 +0900</pubDate><guid>https://tech-memo.meijin.dev/posts/zellij-intro/</guid><description>Macにtmuxを入れたくなったけど、もうこのご時世だしRust製の類似品が誰かによって作られているのではと思ったらあった。
インストール cargoで入れることができる。cargoが古いと入らないので、その場合はcargo自体を入れ直すとよい
基本操作 c-p でペインモード。操作法は画面下部に出てくる。同じくc-pで編集モードに戻れることに注意 キーバインドは~/.config/zellij/config.yamlに掻き集めて編集する。Ctrl-rが取られていたのでそこの設定を書き換えた。c-zにしてある c-t でタブモードらしいがまだ使っていない 公式Doc https://zellij.dev/documentation/commands.html
記事 https://zenn.dev/gosarami/articles/4becaa18273216fec5ee</description></item><item><title>次の10年では、「何者にもならなくていいSNS」が伸びると思う理由</title><link>https://tech-memo.meijin.dev/posts/next-sns-thinking/</link><pubDate>Mon, 20 Sep 2021 00:00:00 +0900</pubDate><guid>https://tech-memo.meijin.dev/posts/next-sns-thinking/</guid><description>2020年までのSNSは「何者かになれるSNS」でした。 これからの10年では「何者にもならなくていいSNS」が伸びると考えており、その点について思考を整理するメモを置いておきます。
まず、「何者かになれるSNS」における「何者」について説明します。
「何者」の例で一番わかり易いのはインフルエンサー、YouTuberといった、多くの人からネット上で人気や支持を獲得する職業です。 また、職業にはならなくても、現実世界の仕事では有名ではないけどTwitterなどでは数千、数万フォロワー持っているような方も含みます。
そういった「何者」にみんなの視線が集まり、憧れられる世界観がこの10年のTwitter、Instagram、Tiktok、Youtubeなどによって作られました。 フォロワー数、チャンネル登録者数、再生数などで優劣がついている世界観がこれらのサービス上では展開されており、それらが多いだけで、あたかも「何者か」になったような扱いをうけることができます。
もちろんこれらのSNSで人気になっている方たちは喋りが上手だったり、動画編集技術が優れていたり、可愛い猫を飼っていたり、なにかしら特長を持っているからこそ人気なわけです。それでも、たとえばプロ野球選手や歌手、書道家などの技術を持っているから有名になった方たちとは違って、より「自分もこういう人になれるかも、なれたかもしれない」と思わせるような身近な存在である点が大きく異なると考えています。ましてや、Twitterで数千フォロワーを持っているようなアカウントならば、もっと身近な存在です。
僕は東海オンエアさんというYouTuberの動画をよく見ます。彼らがやっていることはネタ動画を毎日のように投稿しているだけです。僕がいま10年前にタイムスリップして、プロ野球選手かYouTuberのどちらかになれと言われたら、なんとなくYouTuberになるほうが簡単に思えるでしょう（もちろんそんなことはありません。どちらも相当大変なはずです）。事実簡単かどうかではなく、自分もなれるかもしれないと思わせるような存在であることが大事なのです。
これまでのSNSは、とにかく閲覧数、滞在時間、取引額の増加などが収益に直結するため、そこで活躍するフォロワーの多いアカウントをどんどんフィーチャーしていきます。 なので、Twitterを使っているとフォロー数やフォロワー数を増やすことが推奨されるようにUI上で案内されることも多いですし、YouTubeは誰でも無料ですぐ配信者になることができます。SNS運営側からすると、誰でもいいから誰かがこのサービス上でスターになってくれ、と言わんばかりの設計になっているわけです。
しかし、そういったフォロワーが増えることが正しい、どんどん自分の投稿を不特定多数に見られるようにしようというサービス側の動きが、炎上や、SNS疲れといった負の側面を生み出しています。 炎上はもちろん炎上させる側、した側も悪いかもしれませんが、一番はそういった動きを起こすことが広告収益につながるようにプラットフォームが設計されていることに問題があります。
自分は数千フォロワーなんて目指していない！という方にとっても、自分の投稿にリアクションがほしければ原則フォロワーを増やすしかありません。キャリアSNSのYOUTRUSTも、友だちの友だちまで投稿が届くような設計にしていることで、関係性がなくてもフォローリクエストを送る人が散見されています（2021年9月時点です）。このように、SNSから提供される価値を享受するにはフォロワーを増やすことが早い→フォロワーが増えると発信力が上がり何者かになったかのように錯覚する、という流れは意図的に設計されているといえるでしょう。
極端な例だと、「何者かになれる」ように見えることで危険なあこがれを持ってしまう事例も考えられます。 いまYouTuberとしてトップラインを走っている方たちは心底その仕事が好きで、動画配信に命を賭けれるような熱意を持っている方ばかりでしょうが、そういう気持ちでなくてもいきなりYouTuberを始められてしまうことで、これまで堅実に会社員を歩んでいたのにある日突然YouTuberを目指して会社をやめてしまい、失敗してしまうような例も中にはあるかもしれません。僕の周囲にはこういった事例は見当たらないですが、近いことは多く起こっているのではないでしょうか。これも「何者かになれる」と見えるように設計されたSNSの負の側面です。
何者かになれるSNSがある事自体は否定しませんが、そろそろそれ以外のコンセプトのSNSも主流になるのかなと見込んでいます。 それが「何者にもならなくていいSNS」です。
僕が現状考えている「何者にもならなくていいSNS」に一番近い存在は「LINEオープンチャット」です。
オープンチャットは突然匿名でアカウントを作成でき、決まったテーマの部屋に入ってざっくばらんにやり取りができます。これまでは個人のアカウントベースでつながるSNSでしたが、オープンチャットのコンセプトは「テーマでつながる」という点が特徴的です。
そもそも、個人はいろいろな側面をもっています。仕事人としての側面、家庭での側面、趣味での側面などです。 これらの側面を各サービスで1アカウントで表現しようという世界観でSNSは構成されていました。Facebookではある個人のアカウントが仕事の話をしたと思えば翌週には結婚報告をして、次の日には趣味の話をすることができます。
他方、オープンチャットはテーマでのみ部屋が作られており、それぞれの投稿者がこれまでどんな部屋にいたアカウントか、などの情報は現れてきません。 このような体験が「何者にもならなくていいSNS」で実現されています。
いちいち自分はこういう者です、フォローしてくださいなどと言わなくても、まずは共通で興味を持っているテーマをベースにしてやり取りを行うところからスタートします。旧来のSNSは興味のあるアカウントを探してフォローしてからスタートだったのですからこれは全く違う体験です。
そういえば、Zoomは、旧来のビデオ通話ツールはまずアカウントを作って相互フォローになってから通話を始めるものだったのに対して、いきなりURLを送って話すことができるのが画期的なUXでした。 最近の企業の採用活動はZoomでカジュアル面談をして、意気投合したらSNSで相互フォローになります。体験が逆の順番になっているのです。
つまるところ、各個人がSNS上からつながりを増やすために頑張ってプロフィールを着飾って背伸びした投稿をしていたこれまでの体験が否定されており、各個人が興味を持っていたり強みのあるテーマに対応した「部屋」のようなものに入って交流するところから繋がりが起こるように変わってきているのです。
僕の趣味は将棋なのですが、これまでのSNS経由で将棋友だちを増やそうと思ったら、まずはTwitterで将棋アカウントをつくって、プロフィールを考えて、アバター画像を貼って、将棋のツイートを日々続けて、フォローバックしてくれそうな人をフォローして、リプライをして、仲良くなったら将棋に誘うみたいな手順を踏むのが普通でしょう。 しかし、オープンチャットのように、テーマでつながるように構成された仕組みがあれば、最初から将棋について話せる、指せる場がネット上に構築されていてそこからいきなり入れるようになり、同じような棋力の友人ができる世界観が考えられます。 オンラインで将棋が指せるサービスはいくつかありますが、町道場のように指したあとに会話したり繋がっていける仕組みまで構築しているサービスはまだ無いはずです。それはオンライン将棋はマッチングの仕組みやAIによるサポートに全力を割いていたからで、ユーザーのペインを将棋友だちがほしい、に言い換えたら全然別の仕組みが考えられると思います。
こういった仕組みが構築されれば、インターネット上で頑張って何者かになろうとしなくてよくなるはずです。
技術は螺旋状に進化します。ここまで説明した内容は10年以上前の2ちゃんねるといったSNSに先祖返りしているように見えるかもしれませんが、アフターコロナ、ビデオ通話技術の民主化、スマートフォンの進化、ネット環境の普及、XR技術の進歩などを加味すると、改めて「何者にもならなくていいSNS」が普及していくように思えてなりません。
とはいえ、「何者にもならなくていいSNS」はまだ考慮すべき点が多いです。マネタイズの手段、テーマの選定、トラブルの防止、UXの設計などです。 ひとつだけ言えるのは、既存のSNSのように、特定のアカウントに人気が集中することがサービスの収益に直結するように設計してはならないということです。あくまで、狙ったテーマに人が集まって、目的通りに会話したり楽しい場を作ることに注力することがサービスの収益につながるように設計されたビジネスモデル、プロダクトでなければなりません。
これからも考察を続けていこうと思います。</description></item><item><title>Notionに無課金でGoogle Analyticsを設定する方法</title><link>https://tech-memo.meijin.dev/posts/notion-google-analytics/</link><pubDate>Fri, 17 Sep 2021 00:00:00 +0900</pubDate><guid>https://tech-memo.meijin.dev/posts/notion-google-analytics/</guid><description>Notion本体にGoogle Analyticsを埋め込める機能はなく、以下のようにカスタムドメインなども設定できる外部サービスでならGoogle Analyticsが設定できるものと思っていた。
https://wraptas.com/manual#block-ee356f6cd6f543a4920292cfd5c4ce97 https://super.so/guides/google-analytics ところが、Google Analyticsを埋めたいだけならEmbed機能を使って実現できることを知ったのでやってみたメモ
https://apption.co/apps/2 この機能を使うだけ。
https://notion-ga.astrocket.vercel.appというどこの誰が作っているのかわからないドメインなので、動作の安定を取りたいなら前述のサービスを使うのがいいが、取れたら良いな〜くらいの温度感だとこっちを使うほうが手軽でよいなと思った。
ちなみにこの方法はGA4には対応していないので、該当するプロパティを作るときはユニバーサルアナリティクスで作成しないといけないので注意。</description></item><item><title>React Native開発用Android Emulatorセットアップ</title><link>https://tech-memo.meijin.dev/posts/rn-android-emulator/</link><pubDate>Fri, 17 Sep 2021 00:00:00 +0900</pubDate><guid>https://tech-memo.meijin.dev/posts/rn-android-emulator/</guid><description>メモ風に書いておく。
https://docs.expo.dev/workflow/android-studio-emulator/
これを見ながら環境のセットアップをする。ゴールとしてはadbコマンドがローカルで動いていたらOK。
そのままAndroid Studioを起動して、AVD Managerから任意の端末を再生ボタンで起動する。
起動が終わったら、expo startしているターミナルにてaを押せばAndroidエミュレータ内でアプリが起動する。
アプリ内に最初は画像やファイルがまったくないが、
画像はカメラアプリから撮影すると入る ファイルは、自分のPCからドラッグアンドドロップするとDownloadsフォルダに入る ので、これでテストができる。
ReloadなどのメニューはCommand + Mで出せる</description></item><item><title>どうやってZennは本文中のURLを動的にOGP画像つきのCardにしているのか</title><link>https://tech-memo.meijin.dev/posts/how-to-include-dynamic-site-card/</link><pubDate>Thu, 16 Sep 2021 10:03:00 +0900</pubDate><guid>https://tech-memo.meijin.dev/posts/how-to-include-dynamic-site-card/</guid><description>Zennの記事では、本文中のURLがカードとして表示される。
https://zenn.dev/meijin/articles/linaria-class-name-config
これは初期ロード時はPlaceholderが掛かっているため、フロントエンドで動的に表示できていると推測できる。
この仕組みを少しだけ調査したのでメモ。
Zenn本体のソースは公開されていないはずだが、CLIのソースは公開されているため、ほぼ同様の技術とみなして調査できる。
markdownをHTMLにパースするときに、URLを見つけたらiframeに変換している。
https://github.dev/zenn-dev/zenn-editor/blob/43d8da8b77456c72f3b820f6e5df4ccf69d14ea9/packages/zenn-markdown-html/src/utils/md-linkify-to-card.ts
// 以下の2つをどちらも満たした場合にリンク化 // 1. パラグラフ先頭 もしくは リンクの前が br // 2. パラグラフの末尾 もしくは リンクの後が br const shouldConvertToCard = (isStartOfLine || isPrevBr) &amp;amp;&amp;amp; (isEndOfLine || isNextBr); if (!shouldConvertToCard) { newTokens.push(token); // 変換は行わずに出力結果に含める return; } // 埋め込み用のHTMLを生成 const embedToken = new Token(&amp;#39;html_inline&amp;#39;, &amp;#39;&amp;#39;, 0); if (isTweetUrl(url)) { embedToken.content = generateTweetHtml(url); } else if (isYoutubeUrl(url)) { embedToken.content = generateYoutubeHtmlFromUrl(url); } else { embedToken.</description></item><item><title>React Native Webviewでページ内のJavaScriptイベントをアプリ側でハンドリングする</title><link>https://tech-memo.meijin.dev/posts/rn-webview-javascript-handling/</link><pubDate>Thu, 16 Sep 2021 00:00:00 +0900</pubDate><guid>https://tech-memo.meijin.dev/posts/rn-webview-javascript-handling/</guid><description>こちらに書いてあるまんまなんだけど。
https://github.com/react-native-webview/react-native-webview/blob/master/docs/Guide.md#communicating-between-js-and-native
React Native側 onMessage={(event) =&amp;gt; { alert(event.nativeEvent.data); }} Webview側 // @ts-ignore window.ReactNativeWebView.postMessage({ status: &amp;#39;completed&amp;#39; }) windowにReactNativeWebViewというのが生えるのでそれを使って通信するとハンドリングできる。iframeみたい。</description></item><item><title>React NativeでWebviewを使った際にユーザーのアクションでリロードさせる</title><link>https://tech-memo.meijin.dev/posts/rn-webview-reload/</link><pubDate>Wed, 15 Sep 2021 12:03:00 +0900</pubDate><guid>https://tech-memo.meijin.dev/posts/rn-webview-reload/</guid><description>refを使って、onReloadといった任意のイベントハンドラでcurrent!.reload()させると手動でリロードが出来ます。 普通はpullToRefreshEnabledを使えば対応できると思いますが、こういう方法もあるということで。
import { View } from &amp;#34;../components/Themed&amp;#34;; import { WebView } from &amp;#34;react-native-webview&amp;#34;; import { Fab, Icon } from &amp;#34;native-base&amp;#34;; import { AntDesign } from &amp;#34;@expo/vector-icons&amp;#34;; export default function WebviewScreen() { const webview = useRef&amp;lt;WebView&amp;gt;(null) const onReload = () =&amp;gt; { webview.current!.reload() } return ( &amp;lt;View style={styles.container}&amp;gt; &amp;lt;WebView ref={webview} pullToRefreshEnabled={true} source={{ uri: &amp;#34;https://expo.dev&amp;#34;, }} /&amp;gt; &amp;lt;Fab right={30} bottom={60} icon={ &amp;lt;Icon color={&amp;#34;white&amp;#34;} as={&amp;lt;AntDesign name={&amp;#34;heart&amp;#34;}/&amp;gt;} /&amp;gt; } onTouchEnd={onReload} /&amp;gt; &amp;lt;/View&amp;gt; ); }</description></item><item><title>[WIP]scikit-learn入門</title><link>https://tech-memo.meijin.dev/posts/scikit-learn-introduction/</link><pubDate>Tue, 14 Sep 2021 22:09:27 +0900</pubDate><guid>https://tech-memo.meijin.dev/posts/scikit-learn-introduction/</guid><description>目標 scikit-learnを用いて、MLに関する基本的な操作ができるようになる。データセットは既存のものを用いてもいい 次に、データセットを独自で用意するかカスタマイズした上で同様の操作を行えるようになる これらの学習を通して、MLの概観について改めて（ある程度エンジニアリングに素養がある人に対して）話せるレベルで理解する ついでに英語力も高まるとなおよし まずは公式ないし公式を元にしたものから記事収集 https://scikit-learn.org/stable/getting_started.html https://scikit-learn.org/stable/tutorial/index.html https://tutorials.chainer.org/ja/09_Introduction_to_Scikit-learn.html https://qiita.com/sugulu_Ogawa_ISID/items/e3fc39f2e552f2355209 手順 https://www.jetbrains.com/ja-jp/dataspell/
こちらのIDEの早期アクセスを使ってJupyter Notebook上で動かしてみる。早期アクセスが終わったら、VSCを使うか課金する。これらのNotebookはGitHubに置いておく。
チュートリアル和訳＆コーディング https://scikit-learn.org/stable/tutorial/basic/tutorial.html Machine learning: the problem setting¶
機械学習：問題の設定
In general, a learning problem considers a set of n samples of data and then tries to predict properties of unknown data. If each sample is more than a single number and, for instance, a multi-dimensional entry (aka multivariate data), it is said to have several attributes or features.</description></item><item><title>react-hook-formで入力内容の変更を追跡する</title><link>https://tech-memo.meijin.dev/posts/react-hook-form-watch/</link><pubDate>Tue, 14 Sep 2021 22:08:51 +0900</pubDate><guid>https://tech-memo.meijin.dev/posts/react-hook-form-watch/</guid><description>useFormの返り値でwatchが手に入るのでそれを使う
https://react-hook-form.com/api/useform/watch/</description></item><item><title>jestで各テストケースの前にかならずモックをクリアする</title><link>https://tech-memo.meijin.dev/posts/jest-mock-clear-always/</link><pubDate>Tue, 14 Sep 2021 22:08:15 +0900</pubDate><guid>https://tech-memo.meijin.dev/posts/jest-mock-clear-always/</guid><description>https://jestjs.io/ja/docs/configuration#clearmocks-boolean
jest.config.jsに
clearMocks: true を書き足す</description></item><item><title>固定ヘッダーを利用しているときに、scrollIntoViewでスクロールした先が隠れてしまう問題を解消する</title><link>https://tech-memo.meijin.dev/posts/fixed-header-scroll-view/</link><pubDate>Tue, 14 Sep 2021 22:03:50 +0900</pubDate><guid>https://tech-memo.meijin.dev/posts/fixed-header-scroll-view/</guid><description>scroll-margin-top: 70px; これで解決できます。
scroll into view fixed headerでググりました。
https://www.bram.us/2020/03/01/prevent-content-from-being-hidden-underneath-a-fixed-header-by-using-scroll-margin-top/
https://stackoverflow.com/questions/13614112/using-scrollintoview-with-a-fixed-position-header
と思いきや、2021年9月現在Safariで動作しないので、以下の記事のように力技で対応する必要がある。辛い。
https://zenn.dev/catnose99/articles/75d3c69bf71bad</description></item><item><title>Dayjsのコンストラクタに渡せる、Date型とか文字列型のUnion型はDayjs側で提供されている</title><link>https://tech-memo.meijin.dev/posts/dayjs-types-tips/</link><pubDate>Tue, 14 Sep 2021 22:03:00 +0900</pubDate><guid>https://tech-memo.meijin.dev/posts/dayjs-types-tips/</guid><description>ConfigTypeという型がエクスポートされています。
https://kossy-web-engineer.hatenablog.com/entry/2020/09/01/223101</description></item><item><title>文字列に平行四辺形の下線を引く</title><link>https://tech-memo.meijin.dev/posts/css-skew-underline/</link><pubDate>Tue, 14 Sep 2021 22:01:53 +0900</pubDate><guid>https://tech-memo.meijin.dev/posts/css-skew-underline/</guid><description>ざっと以下のようなコンポーネントを実装するといい。
import { css } from &amp;#39;linaria&amp;#39;; import { ReactNode } from &amp;#39;react&amp;#39;; type Props = { children: ReactNode; }; const style = css` display: flex; padding: 4px 0; margin-left: 8px; position: relative; white-space: nowrap; z-index: 1; &amp;amp;:after { content: &amp;#39;&amp;#39;; position: absolute; top: 12px; left: -6px; width: calc(100% + 6px); height: 12px; background: #fdfdfd; transform: skewX(-20deg); z-index: -1; } `; export const Underlined = ({ children }: Props) =&amp;gt; { return &amp;lt;span className={style}&amp;gt;{children}&amp;lt;/span&amp;gt;; }; ポイント skew transform: skewX(-20deg); これで右方向に少し歪んだ図形が作れる。</description></item><item><title>overscroll-behavior-x</title><link>https://tech-memo.meijin.dev/posts/css-overflow-scroll-behavior/</link><pubDate>Tue, 14 Sep 2021 21:52:35 +0900</pubDate><guid>https://tech-memo.meijin.dev/posts/css-overflow-scroll-behavior/</guid><description>背景 overscroll-behavior-x https://developer.mozilla.org/ja/docs/Web/CSS/overscroll-behavior-x
X軸方向にスクロールしたとき、要素の両端に到達したときブラウザ標準の挙動を引き起こさないために指定する</description></item><item><title>CSSアニメーションの動きをベジエ曲線にする</title><link>https://tech-memo.meijin.dev/posts/css-animation-bezier/</link><pubDate>Tue, 14 Sep 2021 21:51:18 +0900</pubDate><guid>https://tech-memo.meijin.dev/posts/css-animation-bezier/</guid><description>ease-in-outみたいなデフォルトの動きでは満足しなくなってきたときに使える。
animation-timing-function: cubic-bezier(0.71, 0.35, 1, -0.6); こちらのサイトでシミュレーションできる
https://cubic-bezier.com/#.17,.67,.83,.67</description></item><item><title>composerで公開されていないライブラリをGitHubから直接利用する</title><link>https://tech-memo.meijin.dev/posts/composer-package-tips/</link><pubDate>Mon, 13 Sep 2021 23:49:53 +0900</pubDate><guid>https://tech-memo.meijin.dev/posts/composer-package-tips/</guid><description>https://getcomposer.org/doc/05-repositories.md#package-2
{ &amp;#34;repositories&amp;#34;: [ { &amp;#34;type&amp;#34;: &amp;#34;package&amp;#34;, &amp;#34;package&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;smarty/smarty&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;3.1.7&amp;#34;, &amp;#34;dist&amp;#34;: { &amp;#34;url&amp;#34;: &amp;#34;https://www.smarty.net/files/Smarty-3.1.7.zip&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;zip&amp;#34; }, &amp;#34;source&amp;#34;: { &amp;#34;url&amp;#34;: &amp;#34;http://smarty-php.googlecode.com/svn/&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;svn&amp;#34;, &amp;#34;reference&amp;#34;: &amp;#34;tags/Smarty_3_1_7/distribution/&amp;#34; }, &amp;#34;autoload&amp;#34;: { &amp;#34;classmap&amp;#34;: [&amp;#34;libs/&amp;#34;] } } } ], &amp;#34;require&amp;#34;: { &amp;#34;smarty/smarty&amp;#34;: &amp;#34;3.1.*&amp;#34; } }</description></item></channel></rss>